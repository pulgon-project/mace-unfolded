#!/usr/bin/env python

# Copyright 2025 The PULGON Project Developers
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.

import numpy as np
from ase.atoms import Atoms


def write_lammps_atomic(
    fname, atoms: Atoms, atom_types=None, charges=None, bond_num=None, uelemsort=False
):
    # only write out coordinates without any extra information about bonds dihedrals etc.
    # masses can be added by hand for each element type - otherwise they will automatically
    # be assigned by a table
    # separate atom types can be defined as well
    # if charges are specified - the file type will be "charge" instead
    # if bond_num is given - space for this many bond types will be reserved

    cell = atoms.get_cell().array
    elems = atoms.get_chemical_symbols()
    coors = atoms.positions
    masses = atoms.get_masses()

    with open(fname, "w") as fp:
        fp.write(" # generated by swscripts\n\n")
        fp.write("%12d %s\n" % (len(coors), "atoms"))

        if atom_types is None:
            uelems, uinds = np.unique(elems, return_index=True)
        else:
            uelems, uinds = np.unique(atom_types, return_index=True)
        umasses = masses[uinds]
        if uelemsort:
            logical = np.argsort(uelems)
        else:
            logical = np.argsort(uinds)
        uelems = uelems[logical]
        umasses = umasses[logical]
        fp.write("%12d %s\n" % (len(uelems), "atom types"))
        if bond_num is not None:
            fp.write("%12d %s\n\n" % (bond_num, "bond types"))
        fp.write("\n")
        assert (
            (cell[0, 1] == 0) & (cell[0, 2] == 0) & (cell[1, 2] == 0)
        ), "ERROR during writing lmp file: cell is not an upper triangular matrix!"

        fp.write("%16.10f %16.10f %s %s\n" % (0, cell[0, 0], "xlo", "xhi"))
        fp.write("%16.10f %16.10f %s %s\n" % (0, cell[1, 1], "ylo", "yhi"))
        fp.write("%16.10f %16.10f %s %s\n" % (0, cell[2, 2], "zlo", "zhi"))
        fp.write(
            "%16.10f %16.10f %16.10f %s %s %s\n"
            % (cell[1, 0], cell[2, 0], cell[2, 1], "xy", "xz", "yz")
        )

        fp.write("Masses\n\n")

        for uid, uel in enumerate(uelems):
            fp.write("%12d %14.8f # %s\n" % (uid + 1, umasses[uid], uel))

        fp.write("\nAtoms # atomic\n\n")
        for cid, coor in enumerate(coors):
            if atom_types is not None:
                typeid = np.where(atom_types[cid] == uelems)[0] + 1
            else:
                typeid = np.where(elems[cid] == uelems)[0] + 1
            if charges is not None:
                if bond_num is not None:
                    # in this case it is a hybrid atom style with a different syntax. Here, it is assumed that charge is first, then bond
                    fp.write(
                        "%12d %5d %16.10f %16.10f %16.10f %16.10f %5d\n"
                        % (cid + 1, typeid, coor[0], coor[1], coor[2], charges[cid], 1)
                    )
                else:
                    fp.write(
                        "%12d %5d %16.10f %16.10f %16.10f %16.10f\n"
                        % (cid + 1, typeid, charges[cid], coor[0], coor[1], coor[2])
                    )
            elif bond_num is not None:
                # style bond - need to specify molecule id
                fp.write(
                    "%12d %5d %5d %16.10f %16.10f %16.10f\n"
                    % (cid + 1, 1, typeid, coor[0], coor[1], coor[2])
                )
            else:
                fp.write(
                    "%12d %5d %16.10f %16.10f %16.10f\n"
                    % (cid + 1, typeid, coor[0], coor[1], coor[2])
                )
